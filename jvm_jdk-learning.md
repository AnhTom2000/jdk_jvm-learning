#### 虚拟机的结构
#####操作数栈：
```text
 1 、定义了一个常量2，保存
 istore_1是操作数栈的索引位置
 2 、定义了一个常类3，保存
 istore_2是更新后的操作数栈的索引位置
 3 、iload_1、iload_2 表示分别将索引1和索引2保存的常类加载进来
 4 、iadd 进行相加的指令
 5 、保存为索引3
 6 、返回结果
```
![操作数栈](img/操作数栈.png)

总结 : 
由于跨平台的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不一样，所以不能设计为基于寄存器的。
优点是**跨平台性吗，指令集小，编译器容易实现**
缺点是性能下降，实现同样的功能需要更多的指令

##

#### JVM虚拟机的声明周期

#####虚拟机的启动：	

	Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机具体实现指定的。

#####虚拟机的执行：

	一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序

	程序开始执行时才运行，程序结束时就停止

	执行一个所谓的Java程序时，真真正正是执行一个叫Java虚拟机的进程

#####虚拟机的退出：
分为以下这几种情况：

    1、一个Java程序运行完后自动退出
    2、程序出现异常或出现错误
    3、调用了Rumtime类的half方法或System的exit方法，并且Java安全管理器也允许这次exit或half操作
    
    除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API 来加载或卸载Java虚拟机时，Java虚拟机的退出情况
   
  Runtime类中的exit方法：
   
 ![exit](img/Runtime类中的exit方法.png)
 
 exit方法调用half方法：
 ![half](img/exit中的half方法.png)
 
 half方法调用一个halt0方法：
 
 ![half](img/half.png)
 
 halt0实际调用一个本地方法接口（JNI）：
  ![half](img/halt0.png)


#### 类的生命周期
类的生命周期分为：

加载-->连接-->初始化-->使用-->卸载

其中连接又可以细分为三个部分：

验证-->准备-->解析

##### 加载
加载：

	在加载阶段，类加载器子系统将类的class文件的二进制数据（DNA元数据模板）读取到方法区，并在堆区创建该类的对象



	通常由多种方式能读取到类的class文件：

从磁盘读取：当java文件被编译ide编译成class文件，这时jvm就会将生成的class文件从磁盘读取
 从zip，jar等归档文件夹中读取
 从网络流中读取类的字节流
通过动态生成的字节码技术（如动态代理，cglib等）来动态生成class


PS:虽然加载进去了，但是是否能运行，则由Execution Engine决定（classLoader只负责加载）



具体过程:

通过一个类的全限定类名获取定义此类的二进制字节流
将这个字节流代表的静态存储结构转化为方法去的运行时数据结构
在内存中生成一个代表这个类的java.lang.Class对象，作为这个方法区的各种数据的访问入口